<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dot's DNA Reader</title>
    <!--
    AUTHOR: jeibbiej
    EMAIL: jeibbiej.apps@gmail.com
    DATE: 2025-Mar-11
    -->
</head>
<body>

    <h2>Select Dot Share Card</h2>
    <input type="file" id="imageInput" accept="image/png"><br><br>

    <div id="pixelInfo" style="font-family:Roboto Mono, Consolas, monospace; word-wrap: break-word;"></div>

    <canvas id="canvas" style="display:none;"></canvas>
    <table id="colorRef"></table>

    <script>
        debug = true;

        function GetPixelInt(x, y, ctx)
        {
            const pixel = ctx.getImageData(x, y, 1, 1).data;
            return /*(pixel[3] << 24) |*/ (pixel[0] << 16) | (pixel[1] << 8) | pixel[2]; // ARGB format   
        }

        function GetLightness(x, y, ctx)
        {
            const pixel = ctx.getImageData(x, y, 1, 1).data;
            return (Math.max(pixel[0], pixel[1], pixel[2]) + Math.min(pixel[0], pixel[1], pixel[2])) / (2 * 255);
        }

        function SwapNibbles(dna)
        {
            newdna = 0;
            for (i = 0; i < dna.length; i += 2)
            {
                newdna += dna[i + 1]
                newdna += dna[i];
            }
            return newdna;
        }
        
        document.getElementById('imageInput').addEventListener('change', function(event)
        {
            //document.getElementById('pixelInfo').innerText = "";

            const file = event.target.files[0];

            if (!file || file.type !== "image/png")
            {
                alert("Please select a PNG image.");
                return;
            }

            const img = new Image();
            img.src = URL.createObjectURL(file);
            img.onload = function ()
            {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');

                // Set canvas size and draw image
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                // get ref color
                msg = "";
                debugMsg = "Okay\n";
                //const chkColor = 0x00FFFFFF; //GetPixelInt(0, 0, ctx);
                const chkLite = 0.5;
                x = 1;
                //while (chkColor != GetPixelInt(x, 0, ctx)) { ++x; }
                while (GetLightness(x, 0, ctx) < chkLite)
                {
                    ++x;
                    if (x >= img.width)
                    {
                        alert("Unable to read Dot's Share Card properly.");
                        return;
                    }
                }
                pixSz = x / 17;
                cols = Math.round(img.width / pixSz);

                y = 1;
                //while (chkColor != GetPixelInt(0, y, ctx)) { ++y; }
                while (GetLightness(0, y, ctx) < chkLite)
                {
                    ++y;
                    if (y >= img.height)
                    {
                        alert("Unable to read Dot's Share Card properly.");
                        return;
                    }
                }
                
                rows = Math.round(y / pixSz);
                cols -= rows;
                debugMsg += `x: ${x}, y: ${y}, pixSz: ${pixSz}, rows: ${rows}, cols: ${cols}\n`;
                
                // read reference color
                colorKey = {};
                dna = "";
                halfSz = pixSz / 2;
                
                end = false;
                // read top frame
                cntr = 0;
                for (y = 0; y < rows; ++y)
                {
                    if (end) break;
                    py = Math.ceil(halfSz + pixSz * y);
                    for (x = 0; x < cols; ++x)
                    {
                        px = Math.ceil(halfSz + pixSz * x);
                        color = GetPixelInt(px, py, ctx);
                        if (y == 0 && x < 16)
                            colorKey[color] = x.toString(16).toUpperCase();
                        else if (y == 0 && x == 16)
                            colorKey[color] = -1;
                        else
                        {
                            if (colorKey[color] == -1) { end = true; break; }
                            dna += colorKey[color];
                        }
                    }
                }
                // set color table
                //document.getElementById("colorRef");
                // read left frame
                for (x = 0; x < rows; ++x)
                {
                    if (end) break;
                    px = Math.ceil(halfSz + pixSz * x);
                    for (y = 0; y < cols; ++y)
                    {
                        py = Math.ceil(img.height - halfSz - pixSz * y);
                        color = GetPixelInt(px, py, ctx);
                        if (colorKey[color] == -1) { end = true; break; }
                        dna += colorKey[color];
                    }
                }
                // read bottom frame
                for (y = 0; y < rows; ++y)
                {
                    if (end) break;
                    py = Math.ceil(img.height - halfSz - pixSz * y);
                    for (x = 0; x < cols; ++x)
                    {
                        px = Math.ceil(img.width - halfSz - pixSz * x);
                        color = GetPixelInt(px, py, ctx);
                        if (colorKey[color] == -1) { end = true; break; }
                        dna += colorKey[color];
                    }
                }
                // read right frame
                for (x = 0; x < rows; ++x)
                {
                    if (end) break;
                    px = Math.ceil(img.width - halfSz - pixSz * x);
                    for (y = 0; y < cols; ++y)
                    {
                        py = Math.ceil(halfSz + pixSz * y);
                        color = GetPixelInt(px, py, ctx);
                        if (colorKey[color] == -1) { end = true; break; }
                        if (dna.length >= 1333)
                            msg += "";
                        dna += colorKey[color];
                    }
                }

                //dna += "\0";
                debugMsg += "Code Card DNA: 0123456789ABCDEF_" + dna + "\n";
                msg += "Code Card DNA: " + dna + "\n";

                // DEBUG MESSAGES
                //document.getElementById('pixelInfo').innerText = msg;
                //CloverDNA = "A116A0E08150D24A07D7F353AE4D6CE30410A0E08150D24A07D7F353BFEE60F3041021408020A100A193D088B33EF35187EC91F3814EC05234A8D14CD22847D544A3F0D0C081E8E3510D6CBBD3D18E8D58D324F0D0837FC8E351D229E4F3D17DB1D2F3A222A0F0D080D427F3512E2FF6F3D1574286F3A0F0D0240576D3510D7F57D3D18EFF08D323C080C0518F49DBE3D1E2F4ECE325858510564DCC31EBD6E3C51FEB57F60B48E3D757715AE35810717295EBD810C1138CDB5A10759DD7E3DA10B43E48E35C10B5D0C9EBDC10D62258EB5E1003CA0BDBDE100CC6C0F3DF10C8CF6FE3D8207EF35AC359207D4730F32A1033D0993941D351CADB84E3D14E5D1F3C5267074B3CD2A296724C0370D340B8EC140420D480FC0A0C5566A76CE3D54D93B4240630AF10A0D08F3D39F351D0FB5AF3AC2090A01010224086561646A93013A0F0D0890EACD3D10BCBFAE3524384F1E32141D08125A8E3510466D5F3D10720D2E3528732B7F3D17F1B87F3523AC827F32F30A910808FD0A1F2D0759621F3517D6A82E3D188B080F352F903C8F3D2638E7DE35335CF01F3D300F394E35485D695FBD40B6797F325000210A2F2D0221D3EE351A3CE2EE3D1E6B634F352CF4FADE3D202D9A9E353954B16F3D3650F76FB54294BC5F3D40DB59BE325000310A3F2D0363C00E351334D74F3D12B09B5F352CC1FA5E3D28CD262E35344137AE3D3C8F6EFE3540462D0DBD400E88AE32500AF30181080A0210251976651F352000008F3D2000008F353000008F35412EE470C2500D5CE1589F3A1A2D0116559D351DCCCC4F3D1000008F352A8C011F3539FF2E7E354A1B038E3D4000008FB2500D58615DDF322F2D047723FE351E98607F3D1000008F352E4E21EE3D2000008F35317DADBE3548C1589E3D4000008FB2500D5000008F3AB4000";
                //debugMsg += "Clover's DNA: 0123456789ABCDEF_______" + CloverDNA + `\n`;
                // skip = 6;
                // for (i = 0; i < dna.length - skip; ++i)
                // {
                //     if (CloverDNA[i] != dna[i + skip])
                //     {
                //         debugMsg += `CloverDNA[${i}] != dna[${i + skip}]`;
                //         break;
                //     }
                // }
                if (debug) msg =  debugMsg + "\n-----\n" + msg;
                //document.getElementById('pixelInfo').innerText = msg;

                const genome = new Genome(dna);
                msg = "\n==========\nJSON: " + genome.toString();
                document.getElementById('pixelInfo').innerText = msg;
            };
        });
        //A116A0E08150D24A07D7F353AE4D6CE30410A0E08150D24A07D7F353BFEE60F3041021408020A100A193D088B33EF35187EC91F3814EC05234A8D14CD22847D544A3F0D0C081E8E3510D6CBBD3D18E8D58D324F0D0837FC8E351D229E4F3D17DB1D2F3A222A0F0D080D427F3512E2FF6F3D1574286F3A0F0D0240576D3510D7F57D3D18EFF08D323C080C0518F49DBE3D1E2F4ECE325858510564DCC31EBD6E3C51FEB57F60B48E3D757715AE35810717295EBD810C1138CDB5A10759DD7E3DA10B43E48E35C10B5D0C9EBDC10D62258EB5E1003CA0BDBDE100CC6C0F3DF10C8CF6FE3D8207EF35AC359207D4730F32A1033D0993941D351CADB84E3D14E5D1F3C5267074B3CD2A296724C0370D340B8EC140420D480FC0A0C5566A76CE3D54D93B4240630AF10A0D08F3D39F351D0FB5AF3AC2090A01010224086561646A93013A0F0D0890EACD3D10BCBFAE3524384F1E32141D08125A8E3510466D5F3D10720D2E3528732B7F3D17F1B87F3523AC827F32F30A910808FD0A1F2D0759621F3517D6A82E3D188B080F352F903C8F3D2638E7DE35335CF01F3D300F394E35485D695FBD40B6797F325000210A2F2D0221D3EE351A3CE2EE3D1E6B634F352CF4FADE3D202D9A9E353954B16F3D3650F76FB54294BC5F3D40DB59BE325000310A3F2D0363C00E351334D74F3D12B09B5F352CC1FA5E3D28CD262E35344137AE3D3C8F6EFE3540462D0DBD400E88AE32500AF30181080A0210251976651F352000008F3D2000008F353000008F35412EE470C2500D5CE1589F3A1A2D0116559D351DCCCC4F3D1000008F352A8C011F3539FF2E7E354A1B038E3D4000008FB2500D58615DDF322F2D047723FE351E98607F3D1000008F352E4E21EE3D2000008F35317DADBE3548C1589E3D4000008FB2500D5000008F3AB4000


        class Genome
        {
            constructor(dna)
            {
                this.raw = String(dna);
                this.tree = this.InitTree();
                this.obj = this.ReadObject(this.raw, this.tree);
            }

            ReadMultibyte(dna, pos)
            {
                let n = 0;
                let num = 0;
                let shift = 0;
                let i = 0;
                do
                {
                    let a = parseInt(dna[pos + i++], 16);
                    let b = parseInt(dna[pos + i++], 16);
                    n = (b << 4) | a;
                    num += (n & 0x07F) << shift;
                    shift += 7;
                } while (n >>> 7);

                return [num, i];
            }

            ReadString(dna)
            {
                let str = "";
                for (let i = 0; i < dna.length;)
                {
                    let [opcode, sz] = this.ReadMultibyte(dna, i);
                    i += sz;
                    str += String.fromCharCode(opcode);
                }
                return str;
            }

            ReadFloat(dna)
            {
                let num = 0;
                let shift = 0;
                for (let i = 0; i < 8;)
                {
                    let a = parseInt(dna[i++], 16);
                    let b = parseInt(dna[i++], 16);

                    let tmp = a | (b << 4);
                    num |= tmp << shift;
                    shift += 8;
                }

                let buff = new ArrayBuffer(4);
                let view = new DataView(buff);
                view.setUint32(0, num, true);

                return view.getFloat32(0, true);
            }

            ReadObject(dna, tree)
            {
                let obj = {};
                for (let i = 0; i < dna.length;)
                {
                    let [opcode, sz] = this.ReadMultibyte(dna, i);
                    i += sz;

                    let type = opcode & 0x07;
                    let key = opcode >>> 3;

                    if (!tree["genes"].hasOwnProperty(key))
                    {
                        obj["ERROR"] = `Unkown key ${key} for gene '${tree["name"]}' found at ${i}. DNA: ` + dna;
                        return obj;
                    }

                    let branch = tree["genes"][key];
                    let keyName = branch["name"];

                    let val = {};

                    switch (type)
                    {
                        case 0: // xxxx x000 multibyte integer
                        {
                            [val, sz] = this.ReadMultibyte(dna, i);
                            i += sz;
                            break;
                        }
                        case 2: // xxxx x010 object
                        {
                            // read next multi-byte as size
                            let [objSz, sz] = this.ReadMultibyte(dna, i);
                            i += sz;
                            objSz *= 2; // two nibbles
                            let newDna = dna.substring(i, i + objSz);

                            if (branch.isStr)
                            {
                                val = this.ReadString(newDna);
                            }
                            else
                            {
                                val = this.ReadObject(newDna, tree["genes"][key]);
                            }

                            i += objSz;
                            break;
                        }
                        case 5: // xxxx x101 float
                        {
                            let newDna = dna.substring(i, i + 8);
                            val = this.ReadFloat(newDna);

                            i += 8;
                            break;
                        }
                        default:
                        {
                            obj["ERROR"] = `Unkown type ${type} for gene '${tree["name"]}' found at ${i}. DNA: ` + dna;
                            return obj;
                        }
                    }

                    if (branch.isArray)
                    {
                        if (!Array.isArray(obj[keyName]))
                            obj[keyName] = [];
                        obj[keyName].push(val);
                    }
                    else
                        obj[keyName] = val;
                }

                return obj;
            }

            InitTree(isDna)
            {
                let tree = { "name": "Genome",
                    "genes": {
                        1: { "name": "Traits",
                            "genes": {
                                3: { "name": "Pattern",
                                    "genes": {
                                        3: { "name": "ProceduralPattern",
                                            "genes": {
                                                7: { "name": "DorsalReactionDiffusionParameter",
                                                    "genes": {},
                                                },
                                                8: { "name": "VentralReactionDiffusionParameter",
                                                    "genes": {},
                                                },
                                            },
                                        },
                                    },
                                },
                                5: { "name": "Colors",
                                    "genes": {
                                        1: { "name": "Color",
                                            "isArray": true,
                                            "genes": {
                                                1: { "name": "Red",
                                                    "genes": {},
                                                },
                                                2: { "name": "Green",
                                                    "genes": {},
                                                },
                                                3: { "name": "Blue",
                                                    "genes": {},
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        2: { "name": "DotGuid",
                            "genes": {
                            },
                        },
                        4: { "name": "PlayerQueryString",
                            "isStr": true,
                            "genes": {
                            },
                        },
                    },
                };

                if (isDna)
                    return tree["genes"][1];
                else
                    return tree;
            }

            toString()
            {
                return JSON.stringify(this.obj);
            }
        }
    </script>

</body>
</html>